<!DOCTYPE html>
<html lang="zh" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# profile: http://ogp.me/ns/profile#">
    <head>
	<meta charset="utf-8">
	
	<meta name="description" content="">
	<meta name="author" content="David">
	<meta name="robots" content="index,follow">


	<!-- OpenGraph -->
	<meta property="og:property" content="zh">
	<meta property="og:image" content="/assets/images/favicons/apple-touch-icon-180x180.png">

<meta property="og:title" content="ArchStacker's Blog">

	<meta property="og:type" content="website">
	<meta property="og:description" content="">	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>ArchStacker's Blog</title>
	<script type="text/javascript" src="/theme/js/jquery-1.9.1.js"></script>
	<script type="text/javascript" src="/theme/js/bootstrap.js"></script>

	<!-- Bootstrap CSS  -->
	<link rel="stylesheet" href="/theme/css/bootstrap.css"/>
	<link rel="stylesheet" href="/theme/css/responsive.css"/>
	
	<!-- Generated favicons markup -->
	<link rel="apple-touch-icon" sizes="57x57" href="/assets/images/favicons/apple-touch-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="/assets/images/favicons/apple-touch-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/images/favicons/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="/assets/images/favicons/apple-touch-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/assets/images/favicons/apple-touch-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="/assets/images/favicons/apple-touch-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/assets/images/favicons/apple-touch-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="/assets/images/favicons/apple-touch-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicons/apple-touch-icon-180x180.png">
	<link rel="icon" type="image/png" href="/assets/images/favicons/favicon-32x32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="/assets/images/favicons/android-chrome-192x192.png" sizes="192x192">
	<link rel="icon" type="image/png" href="/assets/images/favicons/favicon-96x96.png" sizes="96x96">
	<link rel="icon" type="image/png" href="/assets/images/favicons/favicon-16x16.png" sizes="16x16">
	<link rel="manifest" href="/assets/images/favicons/manifest.json">
	<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico">
	<meta name="msapplication-TileColor" content="#2b5797">
	<meta name="msapplication-TileImage" content="/assets/images/favicons/mstile-144x144.png">
	<meta name="msapplication-config" content="/assets/images/favicons/browserconfig.xml">
	<meta name="theme-color" content="#ffffff">
	<!-- LESS generated css for Nuja theme -->
	<link rel="stylesheet" href="/theme/css/NujaStructure.css"/>
	<!-- Highlight -->
	<link rel="stylesheet" href="/theme/css/pygment.css"/>

	<link href="http://fonts.googleapis.com/css?family=Droid+Serif" rel="stylesheet" type="text/css">
	<link href='http://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
	<link href='http://fonts.googleapis.com/css?family=Roboto+Condensed' rel='stylesheet' type='text/css'>
	<link href='http://fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
	<link href='http://fonts.googleapis.com/css?family=Vollkorn' rel='stylesheet' type='text/css'>
	<!--[if IE]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script>



	<!-- setup feeds and third-party services -->
	<!-- to clean up later for the new theme -->
	<script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-968141-17', 'auto');
ga('send', 'pageview');

	</script>
	<meta name="google-site-verification" content="4TETrzpAoVPu2-VrTpOxQJFmmynS9VzPq_boE45VKa8" />
	<meta name="msvalidate.01" content="E2790C576E7623BE2F59AC965B48361D" />
    </head>
    <body>

	<div class="container">
	    <div class="header-container">
		<header>
		    <a href="/">
			<h4>ArchStacker's Blog 		    </a>

		    <nav>
			<ul>
			    <li><a href="/">Home</a></li>


			</ul>
		    </nav>
		</header>


	    </div>
	    <div class="clearfix"></div>
	    <div class="row">
		<div class="span9">

		    <div class="span10">


<div class="row">
    <div class="span1 metadata alpha">
	<aside>
	    <div class="entry-date">
		<div class="month-day">
		    <time pubdate datetime="2015-07-13T00:00:00+08:00" title="Jul 13, 15">
			Jul.<span class="day">13</span>
			<div class="year">15</div>
		    </time>
		</div>

	    </div>

	</aside> 

    </div>
    <div class="span7">
	<div class="entry-container ">

	    <article  class="entry hentry" >
		<header>
		    <a href="/Analysis-Of-CVE-2015-0002.html" rel="bookmark" title="permalink for CVE-2015-0002漏洞分析" ><h2 class="entry-title">CVE-2015-0002漏洞分析</h2></a>
		    <div class="author-details vcard">

			by <a  class="url fn" href="/author/archstacker.html">ArchStacker</a>  file under <a href="/category/misc.html">misc</a>		    </div>
		</header>
		<div class="entry-content">
		<h1>背景资料</h1>
<h2>CVE-2015-0002漏洞相关资料</h2>
<h3>漏洞简介</h3>
<p>CVE-2015-0002这个漏洞是由Google Project Zero团队的James Forshaw在2014年9月30日向微软提交的漏洞。微软得知这个漏洞之后没有第一时间处理，而Google的漏洞公开期限为90天，因此在90天后的2014年12月29日该漏洞在未被修复的情况下被公布(<a href="https://code.google.com/p/google-security-research/issues/detail?id=118">链接</a>)。Google的这种不等漏洞修复质疑按期公布的方法被很多人认为会让大量计算机暴露在风险中，这种做法是否合理引起了很多的争论。</p>
<h3>关键问题</h3>
<p>该漏洞主要是由于Windows中用于处理应用程序兼容性数据库的<code>NtApphelpCacheControl</code>相关系统调用，在对请求的进程进行权限认证的<code>AhcVerifyAdminContext</code>函数中存在漏洞，有可能使普通用户伪装成管理员绕过认证。</p>
<h3>利用方式</h3>
<p>在Google公布的poc中，在普通用户下调用本需要系统管理员权限的<code>AppHelpCahceUpdate</code>函数，使得当进程执行的时候会执行<code>regsvr32</code>操作，进而执行指定程序。为了能得到系统的权限，还利用了<code>ComputerDefaults.exe</code>这个在默认设置下不会出现UAC相关提示便可以得到系统权限的程序。</p>
<h3>利用结果</h3>
<p>通过Google公布的poc，可以实现在默认UAC配置下可以无提示开启一个具有管理员权限的计算器（calc.exe）程序。</p>
<h3>相关研究</h3>
<p>Google在发布这个漏洞的时候已经对漏洞的基本情况做了介绍。奇虎360技术博客有篇<a href="http://blogs.360.cn/blog/ntapphelpcachecontrol_vulnerability_anaysis/" title="NtApphelpCacheControl漏洞分析">文章</a>对该漏洞做了进一步介绍，<strong>对于这篇文章已经介绍的很明白一些内容，如应用程序兼容性数据库相关操作函数、<code>AhcVerifyAdminContext</code>漏洞出现原因等，本文不再赘述。</strong></p>
<h2>UAC相关资料</h2>
<h3>UAC简介</h3>
<p>UAC（User Account Control，用户帐户控制）是Windows Vista中新出现的安全技术，通过限制应用软件而改进Windows操作系统的安全性。具体介绍参考<a href="https://zh.wikipedia.org/wiki/使用者账户控制">维基百科</a>。</p>
<p>UAC默认为中上等级，但可以<a href="http://windows.microsoft.com/zh-cn/windows/turn-user-account-control-on-off">对其等级进行设置</a>，对于应用的一些比较敏感的操作会弹出对话框，由使用者判断是否可以执行。UAC的出现，使得很多在XP上可以悄悄执行的病毒、木马在之后的系统中难以发挥作用，有效地提高了系统的安全性。</p>
<h3>UAC绕过</h3>
<p>UAC绕过是指可以在不弹出对话框的情况下就得到管理员权限。有很多方法可以完成这个操作，比如<a href="https://github.com/hfiref0x/UACME">UACME</a>就介绍了13种可用的UAC绕过方法。之前也有过通过某些操作绕过UAC的木马程序，甚至有同样是利用接下来要讲到的应用程序兼容性数据库进行绕过的木马<a href="http://mobi.drweb.cn/mod/news/show/?i=208">BackDoor.Gootkit.112</a>。</p>
<p>正因为之前已经有过很多绕过UAC的情况，所以一些人对于这次的安全问题是否算是严格意义上的权限提升漏洞还存在争议，这也有可能是微软迟迟没有对这个漏洞进行修补的原因。</p>
<h2>应用程序兼容性数据库</h2>
<p>在Windows的发展过程中，有很多系统特性的改变，很多的API也都发生了变化，这些都会导致在较新的系统上运行以前的程序可能会遇到兼容性的问题。为了提高系统对软件的兼容性，微软从WindowsXP操作系统开始引入的一项兼容性解决方案，官方名字是<code>Application Compatibility Database</code>。数据库中定义了一系列的规则，可以匹配需要进行兼容性处理的情况，并在需要兼容性处理的时候进行包括修改内存属性开启NX、hook掉某一类的函数等众多功能。</p>
<p>对于应用程序兼容性数据库，国外的Alex ionescu写了<a href="http://www.alex-ionescu.com/?p=39" title="Secrets of the Application Compatilibity Database (SDB)">文章</a>对其进行了介绍。这个系列本来作者是要写九篇，要讲的内容都列好了，可惜最后只完成了四篇，真正关键的地方都没有讲到。这里对这个机制我了解的也不是十分深入，下面就只能按照我的理解大体讲一些。</p>
<h1>源码分析</h1>
<h2>获得Regsvr32的Tag</h2>
<p>主要工作由<code>GetTagForRegsvr32</code>来完成，获取Regsvr32在Shim中的TAGID号。</p>
<p>函数会首先调用<code>resolveSdbFunctions</code>函数，获取sdb相关函数的地址，然后打开sdb数据库<code>%SystemRoot%\AppPatch\sysmain.sdb</code>，遍历所有项，从中查找<code>TAG_EXE_ID</code>的值为<code>{2C7437C1-7105-40D3-BF84-D493A4F62DDB}</code>的项。</p>
<p>这里的sysmain.sdb，一般位于<code>C:\Windows\AppPatch</code>下。在<a href="http://sdb.io/erickson-codeblue.pdf" title="The active use and exploitation of Microsoft's Application Compatibility Framework">这个PPT</a>中的第11页就介绍了几个可以查看sdb文件的工具。其中有微软提供的图形化的<code>Application Compatibility Toolkit</code>，可以查看电脑上应用程序的相关兼容数据库，不过在打开sysmain.sdb的时候会提示<code>This is a system compatibility database</code>，无法打开。我使用的是<a href="http://blogs.msdn.com/b/heaths/archive/2007/11/02/sdb2xml.aspx">sdb2xml</a>这个工具，提取出了sysmain.sdb文件的具体内容。其中<code>EXE_ID</code>符合上面那个的那项为：</p>
<div class="highlight"><pre>    <span class="nt">&lt;EXE&gt;</span>
      <span class="nt">&lt;NAME</span> <span class="na">type=</span><span class="s">&quot;xs:string&quot;</span><span class="nt">&gt;</span>REGSVR32.EXE<span class="nt">&lt;/NAME&gt;</span>
      <span class="nt">&lt;APP_NAME</span> <span class="na">type=</span><span class="s">&quot;xs:string&quot;</span><span class="nt">&gt;</span>RegSvr32<span class="nt">&lt;/APP_NAME&gt;</span>
      <span class="nt">&lt;VENDOR</span> <span class="na">type=</span><span class="s">&quot;xs:string&quot;</span><span class="nt">&gt;</span>Microsoft<span class="nt">&lt;/VENDOR&gt;</span>
      <span class="nt">&lt;EXE_ID</span> <span class="na">type=</span><span class="s">&quot;xs:string&quot;</span> <span class="na">baseType=</span><span class="s">&quot;xs:base64Binary&quot;</span><span class="nt">&gt;</span>{2c7437c1-7105-40d3-bf84-d493a4f62ddb}<span class="nt">&lt;/EXE_ID&gt;</span>
      <span class="nt">&lt;APP_ID</span> <span class="na">type=</span><span class="s">&quot;xs:base64Binary&quot;</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;MATCH_MODE</span> <span class="na">type=</span><span class="s">&quot;xs:short&quot;</span><span class="nt">&gt;</span>2<span class="nt">&lt;/MATCH_MODE&gt;</span>
      <span class="nt">&lt;MATCHING_FILE&gt;</span>
        <span class="nt">&lt;NAME</span> <span class="na">type=</span><span class="s">&quot;xs:string&quot;</span><span class="nt">&gt;</span>*<span class="nt">&lt;/NAME&gt;</span>
        <span class="nt">&lt;UPTO_BIN_PRODUCT_VERSION</span> <span class="na">type=</span><span class="s">&quot;xs:long&quot;</span><span class="nt">&gt;</span>1125904201809919<span class="nt">&lt;/UPTO_BIN_PRODUCT_VERSION&gt;</span>
      <span class="nt">&lt;/MATCHING_FILE&gt;</span>
      <span class="nt">&lt;SHIM_REF&gt;</span>
        <span class="nt">&lt;NAME</span> <span class="na">type=</span><span class="s">&quot;xs:string&quot;</span><span class="nt">&gt;</span>RedirectEXE<span class="nt">&lt;/NAME&gt;</span>
        <span class="nt">&lt;SHIM_TAGID</span> <span class="na">type=</span><span class="s">&quot;xs:int&quot;</span><span class="nt">&gt;</span>159048<span class="nt">&lt;/SHIM_TAGID&gt;</span>
        <span class="nt">&lt;COMMAND_LINE</span> <span class="na">type=</span><span class="s">&quot;xs:string&quot;</span><span class="nt">&gt;</span>+%windir%\system32\regsvr32.exe<span class="nt">&lt;/COMMAND_LINE&gt;</span>
      <span class="nt">&lt;/SHIM_REF&gt;</span>
    <span class="nt">&lt;/EXE&gt;</span>
</pre></div>


<p>可以看到在Shim中保存的<code>COMMAND_LINE</code>会调用<code>+%windir%\system32\regsvr32.exe</code>，进而执行<code>TestDLL.dll</code>调用<code>calc</code>。这也是该poc能利用Shim执行程序的关键所在。</p>
<h2>获取系统的token值</h2>
<p>通过主函数中调用<code>CaptureImpersonationToken</code>获取一个拥有系统管理员权限的token值。主要工作是由<code>DoCaptureToken</code>来做。</p>
<p>为了能拿到具有系统管理员权限的token，这里开启了一个BITS服务，并通过继承IUnknown得到一个FakeObject，作为接受BITS服务通知的COM接口，使得在接受通知的时候能够开启一个客户端获取在运行的BITS服务的模拟token值，通过判断token值对应的SID判断该token是否为具有系统管理员权限的token。</p>
<h3>BITS服务</h3>
<p>BITS服务(Use Background Intelligent Transfer Service)是Windows提供的一个网络服务。这个服务可以用来在客户端和服务器之间异步地传输文件。这个服务最大的特点是它通常运行在后台，会根据网络情况自动调整自己的状态，保证不会影响到其他程序。同时，当用户退出时，当前BITS服务会自动休眠，等到下次用户启动之后，BITS服务会自动继续下载。</p>
<p>BITS服务多被用于Windows补丁下载和微软各个应用软件的更新。</p>
<p><code>DoCaptureToken</code>这个函数主要的工作是开启了一个<code>BitsAuthSample</code>任务。这个任务在一定情况下是具有管理员的token的。代码主要参考的是微软的<a href="https://msdn.microsoft.com/en-us/library/ee663883%28v=vs.85%29.aspx" title="Example: Specifying Server Authentication Credentials for a BITS Transfer Job">文档</a>。不过不同的是，这里通过<code>SetNotifyInterface</code>设置通知接受通知的接口为自己定义的COM接口。</p>
<h3>COM</h3>
<p>COM(Component Object Model)，中文名为组件对象模型，是微软的一套软件组件的二进制接口标准，使得跨编程语言的进程间通信、动态对象创建成为可能。</p>
<h3>FakeObject</h3>
<p>所有COM组件都需要实现IUnknown接口。根据COM元件要实现的基本功能，一个IUnknown接口至少应该包含用于查询的<code>QueryInterface</code>方法和用于元件自我生命管理的<code>AddRef</code>接口和<code>Release</code>接口。</p>
<p>在poc的源码中继承了IUnknown定义了一个FakeObject对象，作为COM接口接受BITS服务的通知并进行处理。该对象除了实现上面提到的三个接口之外，还定义了<code>TryImpersonate</code>这个函数，用来根据当前的调用通过<code>CoImpersonateClient</code>模拟一个客户端，获取当前token对应的句柄，并判断token对应的SID是否为系统的SID。如果是的话，则返回获取的具有系统管理员权限的token对应的句柄。最后，通过<code>RevertToSelf</code>函数退出模拟的客户端。</p>
<p>该对象对IUnknown基本的三个接口的实现也是参考了微软的<a href="https://msdn.microsoft.com/en-us/library/aa362867%28v=vs.85%29.aspx" title="IBackgroundCopyCallback interface">文档</a>。</p>
<h3>SID</h3>
<p>SID(security identifier)是用来区分用户、组和电脑账户的一个结构。每当网络上一个用户被创建的时候都会有一个独一无二的SID。</p>
<p>不过，有些<code>Well-known SIDs</code>用于标记一般的组和一般的用户。这个是一直不变的。其中，用于表示系统权限的SID为<code>S-1-5-18</code>，这也是代码中用于比较的SID。</p>
<h3>Access Token</h3>
<p>这里提到的token即Access Token，是用来描述进程或线程安全上下文的对象。token中的信息包括与进程或线程有关的用户账户的标识和权限。token在很多安全检查中都起到很重要的作用。</p>
<h3>Impersonation Token</h3>
<p>上面提到的模拟token即Impersonation Token。每个进程都有一个主token用来描述与进程相关的用户账户的安全上下文信息。一般线程是没有单独的token的，但是一个线程可以模拟出一个客户端账户。这里的模拟允许线程使用客户端的安全上下文和安全对象进行交互。</p>
<p>这里允许一个普通线程拥有一个系统管理员的模拟token，但是被模拟的Token的SID并不能决定Token就真的拥有对应SID的权利。由微软针对<code>SECURITY_IMPERSONATION_LEVEL</code>的<a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff556631%28v=vs.85%29.aspx" title="SECURITY_IMPERSONATION_LEVEL enumeration">解释</a>，模拟的token共有四个等级：<code>SecurityAnonymous</code>、<code>SecurityIdentification</code>、<code>SecurityImpersonation</code>和<code>SecurityDelegation</code>。其中只有<code>SecurityImpersonation</code>和<code>SecurityDelegation</code>才表示真正可以以相应的安全上下文运行。</p>
<h2>伪造当前线程token值对应用程序兼容性数据库进行操作</h2>
<p>现在已经获取到了管理员token对应的句柄，接下来就可以构造数据对应用程序兼容性数据库进行更新。这里是要根据前面获得的<code>regsvr32</code>项对应的tag的构造相应的数据使得当进程运行的时候自动将运行的进程换为之前提到的<code>regsvr32</code>操作。具体更新细节我这里也不是非常清楚。在构造好要更新的数据后，调用了<code>SetThreadToken</code>将当前线程的模拟token设置为刚才获得的管理员token。接着进行<code>AppHelpUpdate</code>操作时就会由于<code>AhcVerifyAdminContext</code>函检查不严导致在普通用户情况下更改了应用程序兼容性数据库。进行完这个操作之后，通过<code>RevertToSelf</code>函数将模拟token去除。</p>
<p>接着就是运行一个程序。这里要运行的程序时候命令行的第二个参数指定的。正如上面所说，这个程序刚运行起来便会由于应用程序兼容性数据库而换为<code>regsvr32</code>运行。不过正常的进程即使被换为<code>regsvr32</code>也得不到管理员权限的。这里利用了Windows中模拟UAC配置下不会弹出提示自动提权的<code>ComputerDefaults</code>程序，使得<code>regsvr32</code>能以管理员权限启动，进而使得其运行的进程都具有管理员权限。</p>
<h1>动态调试</h1>
<p>这里，我使用两台Virtualbox虚拟机对poc进行调试。其中调试端为64位的Win7，被调试端为32位的Win8.1，使用windbg进行调试。</p>
<p>本来不想修改poc源码的，不过发现如果直接调试的话由于程序运行之后立即就会结束，无法在程序上下断点。为此我还特地去StackOverflow上提了一个<a href="https://stackoverflow.com/questions/31295295/how-to-break-on-the-entry-point-of-a-program-when-debug-in-kernel-mode-with-wind" title="How to break on the entry point of a program when debug in kernel mode with windbg?">问题</a>，不过也没有得到满意的答案。因此，我修改了源码，在<code>_tmain</code>的第一行添加了<code>__asm{ int 3 }</code>，然后以Release的方式进行编译得到新的可执行程序。这样的话当运行程序的时候就可以被调试器捕捉到。</p>
<p>这样做的话还有一个好处，就是正常情况下如果要在内核态调试用户态的程序，必须先通过<code>!process</code>获得要调试程序的地址，再通过<code>.process /i</code>将上下文切到程序里。现在通过添加<code>int 3</code>的方法这两步调试器会自动完成这两件事。可以通过<code>!process -1 0</code>来确定当前位于的进程：</p>
<div class="highlight"><pre>kd&gt; !process -1 0
PROCESS 855e64c0  SessionId: 1  Cid: 0ce8    Peb: 7f165000  ParentCid: 0bf0
    DirBase: 3e2be280  ObjectTable: a07d3500  HandleCount: &lt;Data Not Accessible&gt;
    Image: AppCompatCache.exe
</pre></div>


<p>可见当前进程为要调试的<code>AppCompatCache.exe</code>，地址为<code>855e64c0</code>。</p>
<p>由于我把编译生成的<code>AppCompatCache.pdb</code>放入到<code>Symbol File Path</code>中，这里可以重新加载调试信息：</p>
<div class="highlight"><pre>kd&gt; .reload /user
Loading User Symbols
................
*** WARNING: Unable to verify checksum for AppCompatCache.exe
</pre></div>


<p>加载完成之后可以查看当前用户态模块：</p>
<div class="highlight"><pre>kd&gt; lmu
start    end        module name
00ce0000 00d02000   AppCompatCache C (private pdb symbols)  c:\users\archstacker\desktop\poc\src\release\AppCompatCache.pdb
·········································································
·········································································
·········································································
77d60000 77ec4000   ntdll      (private pdb symbols)  c:\symbols\ntdll.pdb\93706DA6AD4F4B2087941EB59B2E19231\ntdll.pdb
</pre></div>


<p>因为待会需要跟踪token的变化，现在先看看当前的token值：</p>
<div class="highlight"><pre>kd&gt; !token
Thread is not impersonating. Using process token...
_EPROCESS 855e64c0, _ETHREAD 859e2740, _TOKEN a0627030
TS Session ID: 0x1
User: S-1-5-21-2970757628-1617878497-4178485037-1001
·········································································
·········································································
·········································································
Impersonation Level:       Anonymous
TokenType:                 Primary
·········································································
</pre></div>


<p>可以看到这里的模拟级别为<code>Anonymous</code>，即最低级别。不知是不是这里没有模拟token的缘故。</p>
<p>这里提示当前线程不是模拟线程，进程的token为<code>a0627030</code>，属于用户<code>S-1-5-21-2970757628-1617878497-4178485037-1001</code>。</p>
<p>引起token变化的是<code>CoImpersonateClient</code>函数，对此处下断点，查看执行前后token的变化情况：</p>
<div class="highlight"><pre>kd&gt; bp `AppCompatCache!CaptureImpersonationToken.cpp:27`
kd&gt; g
Breakpoint 0 hit
AppCompatCache!FakeObject::TryImpersonate+0x1f:
001b:00ce252f ff153031cf00    call    dword ptr [AppCompatCache!_imp__CoImpersonateClient (00cf3130)]
kd&gt; !token
Thread is not impersonating. Using process token...
_EPROCESS 855e64c0, _ETHREAD 859e2740, _TOKEN a0627030
TS Session ID: 0x1
User: S-1-5-21-2970757628-1617878497-4178485037-1001
·········································································
·········································································
·········································································
Impersonation Level:       Anonymous
TokenType:                 Primary
·········································································
kd&gt; p
AppCompatCache!FakeObject::TryImpersonate+0x25:
001b:00ce2535 85c0            test    eax,eax
kd&gt; !token
Thread is not impersonating. Using process token...
_EPROCESS 855e64c0, _ETHREAD 859e2740, _TOKEN a0627030
TS Session ID: 0x1
User: S-1-5-21-2970757628-1617878497-4178485037-1001
·········································································
·········································································
·········································································
Impersonation Level:       Anonymous
TokenType:                 Primary
·········································································
kd&gt; p
AppCompatCache!FakeObject::TryImpersonate+0x157:
001b:00ce2667 8b4dfc          mov     ecx,dword ptr [ebp-4]
</pre></div>


<p>可以看到调用前后token值并没有发生变化，都是开始时进程的token <code>a0627030</code>，也没有通过接下来的判断。这个具体原因我也不清楚，可能是现在还在做一些初始化工作，还没有开启具有管理员权限的BITS服务。不过token变化确实发生在这个位置，好像是<code>g</code>了十多次会发现token在调用这个函数前后被改变了。</p>
<p>不过这里就不这么麻烦了，清除刚才的断点，在下面的第31行下断点：</p>
<div class="highlight"><pre>kd&gt; bl
 0 e 00ce252f [c:\users\archstacker\desktop\poc\src\appcompatcache\captureimpersonationtoken.cpp @ 27]    0001 (0001) AppCompatCache!FakeObject::TryImpersonate+0x1f

kd&gt; bc 0
kd&gt; bp `AppCompatCache!CaptureImpersonationToken.cpp:31`
kd&gt; g
Breakpoint 0 hit
AppCompatCache!FakeObject::TryImpersonate+0x2d:
001b:00ce253d 8d45f4          lea     eax,[ebp-0Ch]
kd&gt; !token
_ETHREAD 859e2740, _TOKEN a078b030
TS Session ID: 0
User: S-1-5-18
·········································································
·········································································
·········································································
Impersonation Level:       Identification
TokenType:                 Impersonation
·········································································
</pre></div>


<p>可以看到当前的token已经是管理员的token<code>a078b030</code>了，且对应的SID为<code>S-1-5-18</code>，说明该token为管理员的token。同时注意这里的模拟级别为<code>Identification</code>。</p>
<p>不过这里我发现了一个奇怪的地方，就是接下来执行的这一句话会改变token的值：</p>
<div class="highlight"><pre>kd&gt; p
AppCompatCache!FakeObject::TryImpersonate+0x4d:
001b:00ce255d 56              push    esi
kd&gt; !token
_ETHREAD 859e2740, _TOKEN a0735030
TS Session ID: 0
User: S-1-5-18
·········································································
·········································································
·········································································
Impersonation Level:       Identification
TokenType:                 Impersonation
·········································································
</pre></div>


<p>可以看到，这里的token不再是之前的<code>a078b030</code>，而变成了<code>a0735030</code>，同样是管理员的token。按理来说，这里执行的<code>GetCurrentThread</code>和<code>OpenThreadToken</code>不应该改变当前的token啊，我还不太明白这里为什么token的值会变。</p>
<p>可以在此处看看调用关系，看看经过回调函数是如何被执行到的：</p>
<div class="highlight"><pre>kd&gt; k
ChildEBP RetAddr  
0029e004 00ce2690 AppCompatCache!FakeObject::TryImpersonate+0x4d [c:\users\archstacker\desktop\poc\src\appcompatcache\captureimpersonationtoken.cpp @ 33]
0029e018 75e258d7 AppCompatCache!FakeObject::QueryInterface+0x10 [c:\users\archstacker\desktop\poc\src\appcompatcache\captureimpersonationtoken.cpp @ 84]
0029e038 75e3566d combase!CarefullyQueryNewInterface+0x24 [d:\blue_gdr\com\combase\common\carefulqi.cpp @ 24]
0029e07c 75e35835 combase!CStdIdentity::ReleaseCtrlUnk+0x46 [d:\blue_gdr\com\combase\dcomrem\stdid.cxx @ 1259]
0029e0bc 75e3b4fe combase!CStdMarshal::Disconnect+0x3b6 [d:\blue_gdr\com\combase\dcomrem\marshal.cxx @ 3805]
0029e19c 75e3af6a combase!CRemoteUnknown::RemReleaseWorker+0x633 [d:\blue_gdr\com\combase\dcomrem\remoteu.cxx @ 1146]
0029e1b0 760e7ffc combase!CRemoteUnknown::RemRelease+0x15 [d:\blue_gdr\com\combase\dcomrem\remoteu.cxx @ 924]
0029e1d0 7618e46c RPCRT4!Invoke+0x2a
0029e86c 75f2f8d3 RPCRT4!NdrStubCall2+0x331
0029e8b4 75f2f79b combase!CStdStubBuffer_Invoke+0x96 [d:\blue_gdr\com\combase\ndr\ndrole\stub.cxx @ 1590]
0029e940 75e38375 combase!SyncStubInvoke+0x144 [d:\blue_gdr\com\combase\dcomrem\channelb.cxx @ 1666]
0029ea6c 75f30590 combase!CCtxComChnl::ContextInvoke+0x235 [d:\blue_gdr\com\combase\dcomrem\ctxchnl.cxx @ 1377]
0029eb14 75f2ffba combase!AppInvoke+0x258 [d:\blue_gdr\com\combase\dcomrem\channelb.cxx @ 1471]
0029ec60 75e2ecba combase!ComInvokeWithLockAndIPID+0x5ed [d:\blue_gdr\com\combase\dcomrem\channelb.cxx @ 2313]
0029ec94 77c175e3 combase!ThreadWndProc+0x2ad [d:\blue_gdr\com\combase\dcomrem\chancont.cxx @ 683]
0029ecc0 77c17c6c USER32!_InternalCallWinProc+0x23
0029ed40 77c1792b USER32!UserCallWinProcCheckWow+0x1af
0029eda0 77c17991 USER32!DispatchMessageWorker+0x1a1
0029edac 75e95b39 USER32!DispatchMessageW+0x10
0029eddc 75e95d44 combase!CCliModalLoop::PeekRPCAndDDEMessage+0x4f [d:\blue_gdr\com\combase\dcomrem\callctrl.cxx @ 2016]
0029ee08 75e95c26 combase!CCliModalLoop::FindMessage+0x2b [d:\blue_gdr\com\combase\dcomrem\callctrl.cxx @ 2087]
0029ee68 75e95bae combase!CCliModalLoop::HandleWakeForMsg+0x44 [d:\blue_gdr\com\combase\dcomrem\callctrl.cxx @ 1707]
0029ee88 75f3268a combase!CCliModalLoop::BlockFn+0x191 [d:\blue_gdr\com\combase\dcomrem\callctrl.cxx @ 1645]
0029eef4 75f31c83 combase!ThreadSendReceive+0x1d3 [d:\blue_gdr\com\combase\dcomrem\channelb.cxx @ 5778]
0029f03c 75e69ffc combase!CRpcChannelBuffer::SendReceive2+0x1df [d:\blue_gdr\com\combase\dcomrem\channelb.cxx @ 4798]
0029f0fc 75e716f0 combase!ClassicSTAThreadSendReceive+0x209 [d:\blue_gdr\com\combase\dcomrem\callctrl.cxx @ 696]
0029f158 75f31a5b combase!CCtxComChnl::SendReceive+0x238 [d:\blue_gdr\com\combase\dcomrem\ctxchnl.cxx @ 735]
0029f170 7618ed14 combase!NdrExtpProxySendReceive+0x42 [d:\blue_gdr\com\combase\ndr\ndrole\proxy.cxx @ 2017]
0029f670 75f3109b RPCRT4!NdrClientCall2+0x3d8
0029f68c 75e38bb8 combase!ObjectStublessClient+0x6b [d:\blue_gdr\com\combase\ndr\ndrole\i386\stblsclt.cxx @ 215]
0029f69c 00ce2941 combase!ObjectStubless+0xf [d:\blue_gdr\com\combase\ndr\ndrole\i386\stubless.asm @ 171]
0029f724 00ce156a AppCompatCache!DoCaptureToken+0x1c1 [c:\users\archstacker\desktop\poc\src\appcompatcache\captureimpersonationtoken.cpp @ 178]
0029fc74 00ce3fb1 AppCompatCache!wmain+0x17a [c:\users\archstacker\desktop\poc\src\appcompatcache\appcompatcache.cpp @ 174]
0029fcbc 76231793 AppCompatCache!__tmainCRTStartup+0xfe [f:\dd\vctools\crt\crtw32\startup\crt0.c @ 255]
0029fcc8 77dbc206 KERNEL32!BaseThreadInitThunk+0xe
0029fd0c 77dbc1df ntdll!__RtlUserThreadStart+0x20
0029fd1c 00000000 ntdll!_RtlUserThreadStart+0x1b
</pre></div>


<p>可以看到调用关系比较复杂。具体流程是什么、为什么之前十几次都没有得到管理员的token这里却得到了，这些我也还都不是很清楚。</p>
<p>在获取管理员token的handle之后，在<code>_tmain</code>中会通过<code>SetThreadToken</code>函数设置当前线程的token。对此处下断点进行验证：</p>
<div class="highlight"><pre>kd&gt; bp `AppCompatCache!AppCompatCache.cpp:212`
kd&gt; g
Breakpoint 1 hit
AppCompatCache!wmain+0x390:
001b:00ce1780 ff742414        push    dword ptr [esp+14h]
kd&gt; !token
Thread is not impersonating. Using process token...
_EPROCESS 855e64c0, _ETHREAD 859e2740, _TOKEN a0627030
TS Session ID: 0x1
User: S-1-5-21-2970757628-1617878497-4178485037-1001
·········································································
·········································································
·········································································
Impersonation Level:       Anonymous
TokenType:                 Primary
·········································································
kd&gt; p
AppCompatCache!wmain+0x3a0:
001b:00ce1790 8d442424        lea     eax,[esp+24h]
kd&gt; !token
_ETHREAD 859e2740, _TOKEN a0735030
TS Session ID: 0
User: S-1-5-18
·········································································
·········································································
·········································································
Impersonation Level:       Identification
TokenType:                 Impersonation
·········································································
</pre></div>


<p>可以看到当前token在执行完<code>SetThreadToken</code>之后，已经由之前普通的<code>a0627030</code>被换为管理员的token<code>a0735030</code>。</p>
<p>接着执行<code>AppHelpUpdate</code>操作的时候会对改token进行验证。出问题的为<code>ahcache.sys</code>中的<code>AhcVerifyAdminContext</code>函数，下断点后进行跟踪：</p>
<div class="highlight"><pre>kd&gt; bp ahcache!AhcVerifyAdminContext
kd&gt; g
Breakpoint 2 hit
ahcache!AhcVerifyAdminContext:
8bed7a98 8bff            mov     edi,edi
kd&gt; !token
_ETHREAD 859e2740, _TOKEN a0735030
TS Session ID: 0
User: S-1-5-18
·········································································
·········································································
·········································································
Impersonation Level:       Identification
TokenType:                 Impersonation
·········································································
kd&gt; u eip eip+40
ahcache!AhcVerifyAdminContext:
8bed7a98 8bff            mov     edi,edi
8bed7a9a 55              push    ebp
8bed7a9b 8bec            mov     ebp,esp
8bed7a9d 83e4f8          and     esp,0FFFFFFF8h
8bed7aa0 83ec14          sub     esp,14h
8bed7aa3 53              push    ebx
8bed7aa4 56              push    esi
8bed7aa5 57              push    edi
8bed7aa6 bf220000c0      mov     edi,0C0000022h
8bed7aab ff156840ed8b    call    dword ptr [ahcache!_imp__KeGetCurrentThread (8bed4068)]
8bed7ab1 8bf0            mov     esi,eax
8bed7ab3 ff156c40ed8b    call    dword ptr [ahcache!_imp__PsGetCurrentProcess (8bed406c)]
8bed7ab9 89442418        mov     dword ptr [esp+18h],eax
8bed7abd 33db            xor     ebx,ebx
8bed7abf 8d44241c        lea     eax,[esp+1Ch]
8bed7ac3 50              push    eax
8bed7ac4 8d442416        lea     eax,[esp+16h]
8bed7ac8 50              push    eax
8bed7ac9 8d44241b        lea     eax,[esp+1Bh]
8bed7acd 50              push    eax
8bed7ace 56              push    esi
8bed7acf ff157040ed8b    call    dword ptr [ahcache!_imp__PsReferenceImpersonationToken (8bed4070)]
8bed7ad5 8bf0            mov     esi,eax
8bed7ad7 85f6            test    esi,esi
</pre></div>


<p>可以看到这里windbg在识别当前线程的token的时候就识别的是具有管理员权限的模拟token<code>a0735030</code>。不过因为其模拟级别为<code>Identification</code>，只通过模拟token就判断其安全性是不正确的。这也是漏洞的原因所在。</p>
<p>接下来会依次调用<code>KeGetCurrentThread</code>、<code>PsGetCurrentProcess</code>、<code>PsReferenceImpersonationToken</code>三个函数，最终获取当前线程的模拟token。这里猜想，获取的token就是刚刚的<code>a0735030</code>。</p>
<div class="highlight"><pre>kd&gt; pc
ahcache!AhcVerifyAdminContext+0x13:
8bed7aab ff156840ed8b    call    dword ptr [ahcache!_imp__KeGetCurrentThread (8bed4068)]
kd&gt; pc
ahcache!AhcVerifyAdminContext+0x1b:
8bed7ab3 ff156c40ed8b    call    dword ptr [ahcache!_imp__PsGetCurrentProcess (8bed406c)]
kd&gt; pc
ahcache!AhcVerifyAdminContext+0x37:
8bed7acf ff157040ed8b    call    dword ptr [ahcache!_imp__PsReferenceImpersonationToken (8bed4070)]
kd&gt; p
ahcache!AhcVerifyAdminContext+0x3d:
8bed7ad5 8bf0            mov     esi,eax
kd&gt; r eax
eax=a0735030
</pre></div>


<p>可以看到，确实得到的是刚才通过BITS服务得到管理员token<code>a0735030</code>。由对<code>AhcVerifyAdminContext</code>的分析可知，这样的话可以通过验证，以管理员的身份进行<code>AppHelpCahceUpdate</code>操作。</p> </div>
	    </article>

	    <!--
	    in case any image breaks the theme
	    i was going to use :after but it didn't quite work for me, maybe next time-->
	    <div class="clearfix"></div>



	</div>
    </div>
</div>



		    </div>
		</div>
<!-- Sidebar -->
<aside class="span3 remove-bs-margin hidden-phone hidden-tablet">

    <div class="widget-external-links widget">
	<h3 class="widget-header">External Links</h3>
	<div class="widget-content">
	    <ul class="widget-list">
	    </ul>
	</div>
    </div>
    <div class="widget-external-links widget">
        <h3 class="widget-header">Recent Articles</h3>
	<div class="widget-content">
	    <ul class="widget-list">
		<li class="widget-list-item"><a href="/Analysis-Of-CVE-2015-0002.html" title="Read: CVE-2015-0002漏洞分析">CVE-2015-0002漏洞分析</a></li>
	    </ul>
	</div>
    </div>
    <div class="widget-archive-category widget">
	<h3 class="widget-header">Category</h3>
	<div class="widget-content">
	    <ul class="widget-list">
		<li class="widget-list-item"><a href="/category/misc.html">misc.<span>1</span></a></li>

	    </ul>
	</div>
    </div>
    <div class="widget">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- dgzen he -->
	<ins class="adsbygoogle"
	    style="display:inline-block;width:300px;height:600px"
	    data-ad-client="ca-pub-4442880234515975"
	    data-ad-slot="1240455063"></ins>
	<script>
	    (adsbygoogle = window.adsbygoogle || []).push({});
	</script>
    </script>
</div>
		</aside>
	    </div>
	    <!--footer-->
	    <div class="row">
		<div class="span12">
		    <footer>
			<p>Powered by <a href="http://getpelican.org">Pelican</a>.</p>
			<p><a href="">Nuja theme</a> designed by <a rel="bookmark" href="http://dgzen.pw">DGZen</a>.</p>
		    </footer>
		</div>
	    </div>
	</div>


    </body>
</html>